'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (exports) {
  'use strict';

  var _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
    setTimeout(callback, 10);
  };
  var PI2 = Math.PI * 2;
  var imageData = void 0,
    renderCount = void 0;
  var index = void 0,
    startIndex = void 0,
    layerIndex = void 0;
  var origin = void 0,
    particle = void 0,
    touch = void 0,
    touchIndex = void 0,
    rect = void 0;
  var x = void 0,
    y = void 0,
    z = void 0,
    dX = void 0,
    dY = void 0,
    dZ = void 0,
    distance = void 0;
  var force = void 0,
    rForce = void 0,
    angle = void 0,
    intensity = void 0,
    vertices = void 0;
  var canvas = void 0,
    context = void 0,
    data = void 0,
    r = void 0,
    g = void 0,
    b = void 0,
    a = void 0;
  var tick = void 0;
  var rotationX = 0;
  var rotationY = 0;

  var Particle = function () {
    function Particle(optionsParam) {
      _classCallCheck(this, Particle);

      var options = {};
      if (optionsParam) {
        if (optionsParam.nodeName) {
          options = JSON.parse(JSON.stringify(optionsParam.dataset));
          if (optionsParam.nodeName === 'IMG') {
            options.image = optionsParam;
          } else {
            options.wrapperElement = optionsParam;
          }
        } else {
          options = optionsParam;
        }
      }
      this.state = 'stopped';
      this.touches = [];
      this.on('imageLoaded', this._onImageLoaded);
      this._initImage(options);
    }

    _createClass(Particle, [{
      key: 'on',
      value: function on(event, fn) {
        this.events = this.events || {};
        this.events[event] = this.events[event] || [];
        this.events[event].push(fn);
      }
    }, {
      key: 'emit',
      value: function emit(event, params) {
        var events = this.events[event];
        if (events && events.length) {
          for (var eventIndex = 0; eventIndex < events.length; eventIndex++) {
            var cb = events[eventIndex];
            cb.call(this, params);
          }
        }
      }
    }, {
      key: 'start',
      value: function start(optionsParam) {
        var options = optionsParam || {};
        this.initPosition = options.initPosition || this.initPosition;
        this.initDirection = options.initDirection || this.initDirection;
        if (this.canvas) {
          this.canvas.width = this.width;
          this.canvas.height = this.height;
          this.canvas.style.display = '';
        }
        this._initOrigins();
        this._initParticles();
        this._webglSetAttributes();
        if (this.state !== 'running') {
          this.state = 'running';
          if (!this.disableInteraction) {
            if ('ontouchstart' in window || window.navigator.msPointerEnabled) {
              document.body.addEventListener('touchstart', this._touchHandler);
              document.body.addEventListener('touchmove', this._touchHandler);
              document.body.addEventListener('touchend', this._clearTouches);
              document.body.addEventListener('touchcancel', this._clearTouches);
            } else {
              this.canvas.addEventListener('mousemove', this._mouseHandler);
              this.canvas.addEventListener('mouseout', this._clearTouches);
              this.canvas.addEventListener('click', this._clickHandler);
            }
          }
          this._animate();
        }
      }
    }, {
      key: 'stop',
      value: function stop(optionsParam) {
        var options = optionsParam || {};
        this.fadePosition = options.fadePosition || this.fadePosition;
        this.fadeDirection = options.fadeDirection || this.fadeDirection;
        this._fade();
        document.body.removeEventListener('touchstart', this._touchHandler);
        document.body.removeEventListener('touchmove', this._touchHandler);
        document.body.removeEventListener('touchend', this._clearTouches);
        document.body.removeEventListener('touchcancel', this._clearTouches);
        if (this.canvas) {
          this.canvas.removeEventListener('mousemove', this._mouseHandler);
          this.canvas.removeEventListener('mouseout', this._clearTouches);
          this.canvas.removeEventListener('click', this._clickHandler);
        }
      }
    }, {
      key: '_animate',
      value: function _animate() {
        var _this = this;

        if (this.state !== 'stopped') {
          this._calculate();
          this._draw();
          _requestAnimationFrame(function () {
            return _this._animate();
          });
        } else {
          this.emit('stopped');
        }
      }
    }, {
      key: '_onImageLoaded',
      value: function _onImageLoaded(options) {
        this.imageWidth = this.image.naturalWidth || this.image.width;
        this.imageHeight = this.image.naturalHeight || this.image.height;
        this.imageRatio = this.imageWidth / this.imageHeight;
        this.width = this.width || this.imageWidth;
        this.height = this.height || this.imageHeight;
        this.renderSize = (this.width + this.height) / 4;
        if (this.srcImage) {
          this.srcImage.style.display = 'none';
        }
        this._initSettings(options);
        this._initContext(options);
        this._initResponsive(options);
        this.start();
      }
    }, {
      key: '_initImage',
      value: function _initImage(options) {
        var _this2 = this;

        this.srcImage = options.image;
        if (!this.srcImage && options.imageId) {
          this.srcImage = document.getElementById(options.imageId);
        }
        this.imageUrl = options.imageUrl || this.srcImage.src;
        this.image = document.createElement('img');
        this.wrapperElement = options.wrapperElement || this.srcImage.parentElement;
        this.image.onload = function () {
          return _this2.emit('imageLoaded', options);
        };
        this.image.crossOrigin = 'Anonymous';
        if (options.addTimestamp) {
          if (/\?/.test(this.imageUrl)) {
            this.imageUrl += '&d=' + Date.now();
          } else {
            this.imageUrl += '?d=' + Date.now();
          }
        }
        this.image.src = this.imageUrl;
      }
    }, {
      key: '_initContext',
      value: function _initContext(options) {
        this.canvas = options.canvas;
        if (!this.canvas && !this.context && this.wrapperElement) {
          this.canvas = document.createElement('canvas');
          this.wrapperElement.appendChild(this.canvas);
        }
        if (this.convas) {
          this.convas.style.display = 'none';
        }
        this.context = options.context;
        this.renderer = options.renderer || 'default';
      }
    }, {
      key: '_defaultInitContext',
      value: function _defaultInitContext(options) {
        this.context = this.context || this.canvas.getContext('2d');
      }
    }, {
      key: '_webglInitContext',
      value: function _webglInitContext() {
        this.context = this.context || this.canvas.getContext('webgl2') || this.canvas.getContext('experimental-webgl');
        this.fragmentShaderScript = '#version 300 es\n\n        precision highp float;\n\n        in vec4 vColor;\n        out vec4 fragColor;\n\n        void main(void) {\n          // fragColor = vec4(1, 1, 1, 0.1);\n          fragColor = vColor;\n        }\n      ';

        this.vertexShaderScript = '#version 300 es\n\n        precision highp float;\n\n        in vec3 vertexPosition;\n        in vec4 vertexColor;\n        uniform vec3 vertexOffset;\n        uniform float pointSize;\n        uniform float depth;\n        vec3 mirror = vec3(1, -1, 1);\n\n        uniform mat4 modelViewMatrix;\n        uniform mat4 perspectiveMatrix;\n        uniform mat4 rotationMatrix;\n\n        out vec4 vColor;\n\n        void main(void) {\n          gl_Position = rotationMatrix * perspectiveMatrix * modelViewMatrix * vec4(mirror * vertexPosition + vertexOffset, vertexPosition);\n          gl_PointSize = pointSize + max((log(vertexPosition.z) - 3.91) * depth, -pointSize + 1.0);\n          vColor = vertexColor;\n        }\n      ';
        this.context.viewport(0, 0, this.width, this.height);
        var vertexShader = this.context.createShader(this.context.VERTEX_SHADER);
        this.context.shaderSource(vertexShader, this.vertexShaderScript);
        this.context.compileShader(vertexShader);
        if (!this.context.getShaderParameter(vertexShader, this.context.COMPILE_STATUS)) {
          console.log(this.context.getShaderInfoLog(vertexShader));
        }
        var fragmentShader = this.context.createShader(this.context.FRAGMENT_SHADER);
        this.context.shaderSource(fragmentShader, this.fragmentShaderScript);
        this.context.compileShader(fragmentShader);
        if (!this.context.getShaderParameter(fragmentShader, this.context.COMPILE_STATUS)) {
          console.log(this.context.getShaderInfoLog(fragmentShader));
        }
        this.program = this.context.createProgram();
        this.context.attachShader(this.program, vertexShader);
        this.context.attachShader(this.program, fragmentShader);
        this.context.linkProgram(this.program);
        this.context.useProgram(this.program);
        this.vertexPosition = this.context.getAttribLocation(this.program, 'vertexPosition');
        this.context.enableVertexAttribArray(this.vertexPosition);
        this.vertexColor = this.context.getAttribLocation(this.program, 'vertexColor');
        this.context.enableVertexAttribArray(this.vertexColor);
        this.context.clearColor(0.0, 0.0, 0.0, 0.0);
        this.context.enable(this.context.BLEND);
        this.context.disable(this.context.DEPTH_TEST);
        this.context.blendFunc(this.context.SRC_ALPHA, this.context.ONE);
        this.vertexBuffer = this.context.createBuffer();
        this.context.bindBuffer(this.context.ARRAY_BUFFER, this.vertexBuffer);
        this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
        this.vertexOffset = this.context.getUniformLocation(this.program, 'vertexOffset');
        this.context.uniform3f(this.vertexOffset, 0, 0, 1000);
        this.context.vertexAttribPointer(this.vertexPosition, 3.0, this.context.FLOAT, false, 28, 0);
        this.context.vertexAttribPointer(this.vertexColor, 4.0, this.context.FLOAT, false, 28, 12);
        this.uModelViewMatrix = this.context.getUniformLocation(this.program, 'modelViewMatrix');
        this.uPerspectiveMatrix = this.context.getUniformLocation(this.program, 'perspectiveMatrix');
        this.uRotationMatrix = this.context.getUniformLocation(this.program, 'rotationMatrix');
        this.uPointSize = this.context.getUniformLocation(this.program, 'pointSize');
        this.uDepth = this.context.getUniformLocation(this.program, 'depth');
        // this.uVertexColors = this.context.getUniformLocation(this.program, 'vertexColors');
        // this.uVertexIndex = this.context.getUniformLocation(this.program, 'vertexIndex');

        this._webglSetAttributes();
      }
    }, {
      key: '_webglSetAttributes',
      value: function _webglSetAttributes() {
        if (this.renderer === 'webgl') {
          var fieldOfView = 1;
          var aspectRatio = this.canvas.width / this.canvas.height;
          var nearPlane = 10;
          var farPlane = 100;
          var top = nearPlane * Math.tan(fieldOfView * Math.PI / 360.0);
          var bottom = -top;
          var right = top * aspectRatio;
          var left = -right;
          var a = (right + left) / (right - left);
          var b = (top + bottom) / (top - bottom);
          var c = (farPlane + nearPlane) / (farPlane - nearPlane);
          var d = 2 * farPlane * nearPlane / (farPlane - nearPlane);
          var x = 2 * nearPlane / (right - left);
          var y = 2 * nearPlane / (top - bottom);

          var perspectiveMatrix = [x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0];
          var modelViewMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          this.context.viewport(0, 0, this.width, this.height);
          this.context.uniformMatrix4fv(this.uModelViewMatrix, false, new Float32Array(perspectiveMatrix));
          this.context.uniformMatrix4fv(this.uPerspectiveMatrix, false, new Float32Array(modelViewMatrix));
          this.context.uniform1f(this.uPointSize, this.particleSize);
          this.context.uniform1f(this.uDepth, this.depth);
          // this.context.uniform4fv(this.uVertexColors, new Float32Array(this.vertexColors));
          // this.context.uniform1f(this.uVertexIndex, 0);
          this._updateRotation();
        }
      }
    }, {
      key: '_updateRotation',
      value: function _updateRotation() {
        var a = Math.cos(rotationX);
        var b = Math.sin(rotationX);
        var c = Math.cos(rotationY);
        var d = Math.sin(rotationY);
        var rotationMatrix = [c, 0, d, 0, 0, a, -b, 0, -c, b, a, 0, 0, 0, 0, 1];
        this.context.uniformMatrix4fv(this.uRotationMatrix, false, new Float32Array(rotationMatrix));
      }
    }, {
      key: '_webglRenderer',
      value: function _webglRenderer() {
        vertices = new Float32Array(this.vertices);
        this.context.bufferData(this.context.ARRAY_BUFFER, vertices, this.context.STATIC_DRAW);
        this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
        this.context.drawArrays(this.context.POINTS, 0, this.particles.length);
        this.context.flush();
      }
    }, {
      key: '_initSettings',
      value: function _initSettings(options) {
        this.width = options.width * 1 || this.width;
        this.height = options.height * 1 || this.height;
        this.maxWidth = options.maxWidth;
        this.maxHeight = options.maxHeight;
        this.minWidth = options.minWidth;
        this.minHeight = options.minHeight;
        if (this.maxWidth) {
          if (/%$/.test(this.maxWidth)) {
            this.maxWidth = this.width * this.maxWidth.replace('%', '') / 100;
          } else {
            this.maxWidth *= 1;
          }
        }
        if (this.maxHeight) {
          if (/%$/.test(this.maxHeight)) {
            this.maxHeight = this.height * this.maxHeight.replace('%', '') / 100;
          } else {
            this.maxHeight *= 1;
          }
        }
        if (this.minWidth) {
          if (/%$/.test(this.minWidth)) {
            this.minWidth = this.width * this.minWidth.replace('%', '') / 100;
          } else {
            this.minWidth *= 1;
          }
        }
        if (this.minHeight) {
          if (/%$/.test(this.minHeight)) {
            this.minHeight = this.height * this.minHeight.replace('%', '') / 100;
          } else {
            this.minHeight *= 1;
          }
        }
        this.alphaFade = 0.4;
        this.gravity = options.gravity * 1 || 0.08;
        this.particleGap = options.particleGap * 1 || 3;
        this.particleSize = options.particleSize * 1 || 1;
        this.layerCount = options.layerCount * 1 || 1;
        this.depth = options.depth * 1 || 1;
        this.rotationDuration = options.rotationDuration * 1 || 0;
        this.growDuration = options.growDuration * 1 || 200;
        this.waitDuration = options.waitDuration * 1 || 200;
        this.shrinkDuration = options.shrinkDuration * 1 || 200;
        this.shrinkDistance = options.shrinkDistance * 1 || 50;
        this.threeDimensional = options.threeDimensional !== undefined && options.threeDimensional !== 'false' ? !!options.threeDimensional : false;
        this.lifeCycle = options.lifeCycle !== undefined && options.lifeCycle !== 'false' ? !!options.lifeCycle : false;
        this.layerDistance = options.layerDistance || this.particleGap;
        this.initPosition = options.initPosition || 'random';
        this.initDirection = options.initDirection || 'random';
        this.fadePosition = options.fadePosition || 'none';
        this.fadeDirection = options.fadeDirection || 'none';
        this.noise = isNaN(options.noise * 1) ? 10 : options.noise * 1;
        this.disableInteraction = options.disableInteraction;
        this.mouseForce = options.mouseForce * 1 || 30;
        this.clickStrength = options.clickStrength * 1 || 0;
        this.color = options.color;
        this.colorArr = options.colorArr || this.colorArr;
      }
    }, {
      key: '_initResponsive',
      value: function _initResponsive(options) {
        var _this3 = this;

        this.responsiveWidth = this.wrapperElement && options.responsiveWidth;
        if (this.responsiveWidth) {
          this.on('stopped', function () {
            _this3.width = _this3.wrapperElement.clientWidth;
            _this3.start();
          });
          this.wrapperElement.addEventListener('resize', function () {
            if (_this3.width !== _this3.wrapperElement.clientWidth) {
              _this3.stop();
            }
          });
          this.width = this.wrapperElement.clientWidth;
        }
      }
    }, {
      key: '_calculate',
      value: function _calculate() {
        this.vertices = this.renderer === 'webgl' ? [] : false;

        renderCount = 0;
        for (index = 0; index < this.particles.length; index++) {
          origin = this.origins[index];
          particle = this.particles[index];
          dX = origin.x - particle.x + (Math.random() - 0.5) * this.noise;
          dY = origin.y - particle.y + (Math.random() - 0.5) * this.noise;
          dZ = origin.z - particle.z + (Math.random() - 0.5) * this.noise / 1000;
          distance = Math.sqrt(dX * dX + dY * dY + dZ * dZ);
          force = distance * 0.01;
          rForce = force * this.speed;
          particle.vx += rForce * (dX / distance);
          particle.vy += rForce * (dY / distance);
          particle.vz += rForce * (dZ / distance);
          for (touchIndex = 0; touchIndex < this.touches.length; touchIndex++) {
            touch = this.touches[touchIndex];
            dX = particle.x - touch.x;
            dY = particle.y - touch.y;
            dZ = particle.z - touch.z;
            distance = Math.sqrt(dX * dX + dY * dY + dZ * dZ);
            force = this.mouseForce * touch.force / distance;
            rForce = force * this.speed;
            particle.vx += rForce * (dX / distance);
            particle.vy += rForce * (dY / distance);
            particle.vz += rForce * (dZ / distance);
          }
          particle.vx *= this.gravityFactor;
          particle.vy *= this.gravityFactor;
          particle.vz *= this.gravityFactor;
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.z += particle.vz;
          if (0 > particle.x || particle.x >= this.width || 0 > particle.y || particle.y >= this.height) {
            particle.isHidden = true;
            if (this.state === 'stopping') {
              particle.isDead = true;
            }
          } else {
            if (this.state === 'stopping' && !particle.isDead) {
              renderCount++;
            }
            particle.isHidden = false;
          }
          if (this.vertices) {
            x = particle.x - (this.width >> 1);
            y = particle.y - (this.height >> 1);
            z = particle.z;
            a = origin.vertexColors[3];
            this.vertices.push(x, y, z, origin.vertexColors[0], origin.vertexColors[1], origin.vertexColors[2], a);
          }
        }
        if (this.state === 'stopping' && renderCount === 0) {
          this.state = 'stopped';
        }
      }
    }, {
      key: '_defaultRenderer',
      value: function _defaultRenderer() {
        this.depth = Math.max(this.layerDistance * this.layerCount / 2, this.mouseForce);
        this.minZ = -this.depth;
        this.maxZ = this.depth;
        imageData = this.context.createImageData(this.width, this.height);

        for (index = 0; index < this.origins.length; index++) {
          origin = this.origins[index];
          particle = this.particles[index];
          if (!particle.isDead && !particle.isHidden) {
            x = ~~particle.x;
            y = ~~particle.y;
            a = origin.color[3];
            if (this.alphaFade > 0 && this.layerCount > 1) {
              z = Math.max(Math.min(particle.z, this.maxZ), this.minZ) - this.minZ;
              a = a * (1 - this.alphaFade) + a * this.alphaFade * (z / (this.maxZ - this.minZ));
              a = Math.max(Math.min(~~a, 255), 0);
            }
            startIndex = (x + y * this.width) * 4;
            imageData.data[startIndex + 0] = origin.color[0];
            imageData.data[startIndex + 1] = origin.color[1];
            imageData.data[startIndex + 2] = origin.color[2];
            imageData.data[startIndex + 3] = a;
          }
        }
        this.context.putImageData(imageData, 0, 0);
      }
    }, {
      key: '_initParticles',
      value: function _initParticles() {
        this.particles = undefined;
        this.particles = [];
        for (index = 0; index < this.origins.length; index++) {
          origin = this.origins[index];
          particle = {};
          this._initParticlePosition(origin, particle);
          this._initParticleDirection(particle);
          this.particles.push(particle);
        }
      }
    }, {
      key: '_initParticlePosition',
      value: function _initParticlePosition(origin, particle) {
        particle.z = 0;
        switch (this.initPosition) {
          case 'random':
          {
            particle.x = Math.random() * this.width;
            particle.y = Math.random() * this.height;
            break;
          }
          case 'top':
          {
            particle.x = Math.random() * this.width * 3 - this.width;
            particle.y = -Math.random() * this.height;
            break;
          }
          case 'left':
          {
            particle.x = -Math.random() * this.width;
            particle.y = Math.random() * this.height * 3 - this.height;
            break;
          }
          case 'bottom':
          {
            particle.x = Math.random() * this.width * 3 - this.width;
            particle.y = this.height + Math.random() * this.height;
            break;
          }
          case 'right':
          {
            particle.x = this.width + Math.random() * this.width;
            particle.y = Math.random() * this.height * 3 - this.height;
            break;
          }
          case 'misplaced':
          {
            particle.x = origin.x + Math.random() * this.width * 0.3 - this.width * 0.1;
            particle.y = origin.y + Math.random() * this.height * 0.3 - this.height * 0.1;
            break;
          }
          default:
          {
            particle.x = origin.x;
            particle.y = origin.y;
          }
        }
      }
    }, {
      key: '_fade',
      value: function _fade() {
        if (this.fadePosition === 'explode' || this.fadePosition === 'top' || this.fadePosition === 'left' || this.fadePosition === 'bottom' || this.fadePosition === 'right') {
          this.state = 'stopping';
        } else {
          this.state = 'stopped';
        }
        if (this.origins) {
          for (index = 0; index < this.origins.length; index++) {
            this._fadeOriginPosition(this.origins[index]);
            this._fadeOriginDirection(this.particles[index]);
          }
        }
      }
    }, {
      key: '_fadeOriginPosition',
      value: function _fadeOriginPosition(origin) {
        switch (this.fadePosition) {
          case 'random':
          {
            origin.x = Math.random() * this.width * 2 - this.width;
            origin.y = Math.random() * this.height * 2 - this.height;
            if (origin.x > 0) origin.x += this.width;
            if (origin.y > 0) origin.y += this.height;
            break;
          }
          case 'top':
          {
            origin.x = Math.random() * this.width * 3 - this.width;
            origin.y = -Math.random() * this.height;
            break;
          }
          case 'left':
          {
            origin.x = -Math.random() * this.width;
            origin.y = Math.random() * this.height * 3 - this.height;
            break;
          }
          case 'bottom':
          {
            origin.x = Math.random() * this.width * 3 - this.width;
            origin.y = this.height + Math.random() * this.height;
            break;
          }
          case 'right':
          {
            origin.x = this.width + Math.random() * this.width;
            origin.y = Math.random() * this.height * 3 - this.height;
            break;
          }
          default:
          {
            // Stay in place
          }
        }
      }
    }, {
      key: '_initParticleDirection',
      value: function _initParticleDirection(particle) {
        particle.vz = 0;
        switch (this.initDirection) {
          case 'random':
          {
            angle = Math.random() * Math.PI * 2;
            intensity = Math.random();
            particle.vx = this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy = this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'top':
          {
            angle = Math.random() * Math.PI - Math.PI / 2;
            intensity = Math.random();
            particle.vx = this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy = this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'left':
          {
            angle = Math.random() * Math.PI + Math.PI;
            intensity = Math.random();
            particle.vx = this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy = this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'bottom':
          {
            angle = Math.random() * Math.PI + Math.PI / 2;
            intensity = Math.random();
            particle.vx = this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy = this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'right':
          {
            angle = Math.random() * Math.PI;
            intensity = Math.random();
            particle.vx = this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy = this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          default:
          {
            particle.vx = 0;
            particle.vy = 0;
          }
        }
      }
    }, {
      key: '_fadeOriginDirection',
      value: function _fadeOriginDirection(particle) {
        switch (this.fadeDirection) {
          case 'random':
          {
            angle = Math.random() * Math.PI * 2;
            intensity = Math.random();
            particle.vx += this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy += this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'top':
          {
            angle = Math.random() * Math.PI - Math.PI / 2;
            intensity = Math.random();
            particle.vx += this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy += this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'left':
          {
            angle = Math.random() * Math.PI + Math.PI;
            intensity = Math.random();
            particle.vx += this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy += this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'bottom':
          {
            angle = Math.random() * Math.PI + Math.PI / 2;
            intensity = Math.random();
            particle.vx += this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy += this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          case 'right':
          {
            angle = Math.random() * Math.PI;
            intensity = Math.random();
            particle.vx += this.width * intensity * Math.sin(angle) * 0.1;
            particle.vy += this.height * intensity * Math.cos(angle) * 0.1;
            break;
          }
          default:
          {
            particle.vx = 0;
            particle.vy = 0;
          }
        }
      }
    }, {
      key: '_initOrigins',
      value: function _initOrigins() {
        canvas = document.createElement('canvas');
        if (this.responsiveWidth) {
          this.width = this.wrapperElement.clientWidth;
        }
        this.ratio = Math.min(this.width, this.maxWidth || Number.POSITIVE_INFINITY) / Math.min(this.height, this.maxHeight || Number.POSITIVE_INFINITY);
        if (this.ratio < this.imageRatio) {
          this.renderWidth = ~~Math.min(this.width || Number.POSITIVE_INFINITY, this.minWidth || this.imageWidth || Number.POSITIVE_INFINITY, this.maxWidth || Number.POSITIVE_INFINITY);
          this.renderHeight = ~~(this.renderWidth / this.imageRatio);
        } else {
          this.renderHeight = ~~Math.min(this.height || Number.POSITIVE_INFINITY, this.minHeight || this.imageHeight || Number.POSITIVE_INFINITY, this.maxHeight || Number.POSITIVE_INFINITY);
          this.renderWidth = ~~(this.renderHeight * this.imageRatio);
        }
        this.offsetX = ~~((this.width - this.renderWidth) / 2);
        this.offsetY = ~~((this.height - this.renderHeight) / 2);
        canvas.width = this.renderWidth;
        canvas.height = this.renderHeight;
        context = canvas.getContext('2d');
        context.drawImage(this.image, 0, 0, this.renderWidth, this.renderHeight);
        data = context.getImageData(0, 0, this.renderWidth, this.renderHeight).data;
        this.origins = undefined;
        this.origins = [];
        var duration = this.growDuration + this.waitDuration + this.shrinkDuration;
        for (x = 0; x < this.renderWidth; x += this.particleGap) {
          for (y = 0; y < this.renderHeight; y += this.particleGap) {
            index = (x + y * this.renderWidth) * 4;
            a = data[index + 3];
            if (a > 0) {
              var seed = Math.random();
              tick = -Math.floor(seed * duration);
              if (this.colorArr) {
                for (layerIndex = 0; layerIndex < this.layerCount; layerIndex++) {
                  this.origins.push({
                    x: this.offsetX + x,
                    y: this.offsetY + y,
                    z: layerIndex * this.layerDistance + 50,
                    color: this.colorArr,
                    tick: tick,
                    seed: seed,
                    vertexColors: this.colorArr.map(function (c) {
                      return c / 255;
                    })
                  });
                }
              } else {
                r = data[index];
                g = data[index + 1];
                b = data[index + 2];
                for (layerIndex = 0; layerIndex < this.layerCount; layerIndex++) {
                  this.origins.push({
                    x: this.offsetX + x,
                    y: this.offsetY + y,
                    z: layerIndex * this.layerDistance + 50,
                    color: [r, g, b, a],
                    tick: tick,
                    seed: seed,
                    vertexColors: [r / 255, g / 255, b / 255, a / 255]
                  });
                }
              }
            }
          }
        }
        this.speed = Math.log(this.origins.length) / 10;
        this.gravityFactor = 1 - this.gravity * this.speed;
      }
    }, {
      key: '_parseColor',
      value: function _parseColor(strParam) {
        var color = void 0;
        if (typeof strParam !== 'string') {
          return undefined;
        }
        var str = strParam.replace(' ', '');

        if (color = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/.exec(str)) {
          color = [parseInt(color[1], 16), parseInt(color[2], 16), parseInt(color[3], 16)];
        } else if (color = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])/.exec(str)) {
          color = [parseInt(color[1], 16) * 17, parseInt(color[2], 16) * 17, parseInt(color[3], 16) * 17];
        } else if (color = /^rgba\(([\d]+),([\d]+),([\d]+),([\d]+|[\d]*.[\d]+)\)/.exec(str)) {
          color = [+color[1], +color[2], +color[3], +color[4]];
        } else if (color = /^rgb\(([\d]+),([\d]+),([\d]+)\)/.exec(str)) {
          color = [+color[1], +color[2], +color[3]];
        } else {
          return undefined;
        }

        return color;
      }
    }, {
      key: 'renderer',
      get: function get() {
        return this._renderer;
      },
      set: function set(value) {
        this._renderer = value;
        this._draw = this['_' + value + 'Renderer'];
        try {
          this['_' + value + 'InitContext']();
        } catch (e) {
          console.log(e);
          if (value !== 'default') {
            this.renderer = 'default';
          }
        }
      }
    }, {
      key: 'color',
      set: function set(value) {
        this.colorArr = this._parseColor(value);
        if (this.colorArr) {
          if (isNaN(this.colorArr[3])) {
            this.colorArr[3] = 255;
          }
          if (0 < this.colorArr[3] && this.colorArr[3] <= 1) {
            this.colorArr[3] *= 255;
          }
        }
      }
    }, {
      key: '_mouseHandler',
      get: function get() {
        var _this4 = this;

        return function (e) {
          _this4.touches = [{
            x: e.offsetX,
            y: e.offsetY,
            z: 49 + (_this4.layerCount - 1) * _this4.layerDistance,
            force: 1
          }];
        };
      }
    }, {
      key: '_clickHandler',
      get: function get() {
        var _this5 = this;

        return function (e) {
          var strength = _this5.clickStrength;
          _this5.origins.map(function (o) {
            return o.z -= strength;
          });
          setTimeout(function () {
            _this5.origins.map(function (o) {
              return o.z += strength;
            });
          }, 100);
        };
      }
    }, {
      key: '_touchHandler',
      get: function get() {
        var _this6 = this;

        return function (e) {
          _this6.touches = [];
          rect = _this6.canvas.getBoundingClientRect();
          for (touchIndex = 0; touchIndex < e.changedTouches.length; touchIndex++) {
            touch = e.changedTouches[touchIndex];
            if (touch.target === _this6.canvas) {
              _this6.touches.push({
                x: touch.pageX - rect.left,
                y: touch.pageY - rect.top,
                z: 49 + (_this6.layerCount - 1) * _this6.layerDistance,
                force: touch.force || 1
              });
              e.preventDefault();
            }
          }
        };
      }
    }, {
      key: '_clearTouches',
      get: function get() {
        var _this7 = this;

        return function (e) {
          _this7.touches = [];
        };
      }
    }]);

    return Particle;
  }();

  exports.Particle = Particle;
  var Particles = document.getElementsByClassName('next-particle');
  for (var ParticleIndex = 0; ParticleIndex < Particles.length; ParticleIndex++) {
    var elem = Particles[ParticleIndex];
    elem.Particle = new Particle(elem);
  }
})(window);
